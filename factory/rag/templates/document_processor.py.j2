import os
import asyncio
from typing import List, Dict, Any, Optional
from pathlib import Path
import PyPDF2
from docx import Document
import pytesseract
from PIL import Image
import tiktoken
import openai

from utils.text_splitter import TextSplitter
from config import get_env_var


class DocumentProcessor:
    """Processes various document formats and extracts text and metadata"""
    
    def __init__(self, ingestion_config):
        self.ingestion_config = ingestion_config
        self.text_splitter = TextSplitter(ingestion_config.chunking)
        self.encoding = tiktoken.encoding_for_model("gpt-5")
        self.llm_client = None
        self._initialize_llm_client()
    
    def _initialize_llm_client(self):
        """Initialize the LLM client for metadata extraction"""
        azure_endpoint = get_env_var('AZURE_OPENAI_ENDPOINT')
        api_key = get_env_var('AZURE_OPENAI_API_KEY')
        api_version = get_env_var('AZURE_OPENAI_API_VERSION', '2024-02-15-preview')
        
        self.llm_client = openai.AzureOpenAI(
            azure_endpoint=azure_endpoint,
            api_key=api_key,
            api_version=api_version
        )
    
    async def process_document(
        self, 
        file_path: str, 
        filename: str, 
        metadata_fields: List[Dict[str, Any]],
        additional_metadata: Optional[Dict[str, Any]] = None
    ) -> Optional[Dict[str, Any]]:
        """Process a single document and extract text and metadata"""
        try:
            file_ext = Path(filename).suffix.lower().lstrip('.')

            if file_ext == 'pdf':
                text_content = await self._extract_pdf_text(file_path)
            elif file_ext == 'docx':
                text_content = await self._extract_docx_text(file_path)
            elif file_ext == 'txt':
                text_content = await self._extract_txt_text(file_path)
            elif file_ext in ['png', 'jpeg', 'jpg']:
                text_content = await self._extract_image_text(file_path)
            else:
                print(f"Unsupported file type: {file_ext}")
                return None
            
            if not text_content.strip():
                print(f"No text content found in {filename}")
                return None
            
            metadata = await self._extract_metadata(
                file_path, filename, metadata_fields, text_content, additional_metadata
            )
            
            chunks = await self.text_splitter.split_text(text_content)
            
            document = {
                'filename': filename,
                'file_type': file_ext,
                'content': text_content,
                'chunks': chunks,
                'metadata': metadata,
                'chunk_count': len(chunks)
            }
            
            return document
            
        except Exception as e:
            print(f"Error processing document {filename}: {str(e)}")
            return None
    
    async def _extract_pdf_text(self, file_path: str) -> str:
        """Extract text from PDF file"""
        text_content = []
        
        with open(file_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            
            for page_num, page in enumerate(pdf_reader.pages):
                try:
                    page_text = page.extract_text()
                    if page_text.strip():
                        text_content.append(f"Page {page_num + 1}:\\n{page_text}")
                except Exception as e:
                    print(f"Error extracting text from page {page_num + 1}: {str(e)}")
                    continue
        
        return "\\n\\n".join(text_content)
    
    async def _extract_docx_text(self, file_path: str) -> str:
        """Extract text from DOCX file"""
        try:
            doc = Document(file_path)
            text_content = []
            
            for paragraph in doc.paragraphs:
                if paragraph.text.strip():
                    text_content.append(paragraph.text)
            
            return "\\n".join(text_content)
        except Exception as e:
            print(f"Error extracting text from DOCX: {str(e)}")
            return ""
    
    async def _extract_txt_text(self, file_path: str) -> str:
        """Extract text from TXT file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                return file.read()
        except UnicodeDecodeError:
            try:
                with open(file_path, 'r', encoding='latin-1') as file:
                    return file.read()
            except Exception as e:
                print(f"Error reading TXT file: {str(e)}")
                return ""
        except Exception as e:
            print(f"Error extracting text from TXT: {str(e)}")
            return ""
    
    async def _extract_image_text(self, file_path: str) -> str:
        """Extract text from image"""
        pass
    
    async def _extract_metadata(
        self, 
        file_path: str, 
        filename: str, 
        metadata_fields: List[Dict[str, Any]], 
        text_content: str,
        additional_metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Extract metadata based on configured fields"""
        metadata = {
            'filename': filename,
            'file_size': os.path.getsize(file_path),
            'file_type': Path(filename).suffix.lower().lstrip('.'),
        }
        
        # Add additional metadata if provided
        if additional_metadata:
            metadata.update(additional_metadata)
        
        # Extract configured metadata fields
        for field in metadata_fields:
            field_name = field['name']
            field_type = field['type']
            auto_extract = field.get('auto_extract', False)
            
            if field_name in metadata:
                continue  # Already have this field
            
            if auto_extract:
                extracted_value = await self._auto_extract_field(
                    field_name, field_type, text_content, metadata, field
                )
                if extracted_value is not None:
                    metadata[field_name] = extracted_value
            elif field.get('default_value') is not None:
                metadata[field_name] = field['default_value']
        
        return metadata
    
    async def _auto_extract_field(
        self, 
        field_name: str, 
        field_type: str, 
        text_content: str, 
        existing_metadata: Dict[str, Any],
        field_config: Dict[str, Any]
    ) -> Any:
        """Auto-extract a specific metadata field"""
        try:
            # Check if there's a custom prompt template for LLM extraction
            extract_prompt_template = field_config.get('extract_prompt_template')
            
            if extract_prompt_template and self.llm_client:
                # Use LLM for extraction with custom prompt
                return await self._extract_with_llm(
                    field_name, field_type, text_content, extract_prompt_template
                )
            
        except Exception as e:
            print(f"Error auto-extracting field {field_name}: {str(e)}")
            return None
    
    async def _extract_with_llm(
        self, 
        field_name: str, 
        field_type: str, 
        text_content: str, 
        prompt_template: str
    ) -> Any:
        """Extract field value using LLM with custom prompt template"""
        try:
            prompt = prompt_template.format(
                field_name=field_name,
                field_type=field_type,
                content=text_content
            )

            model = get_env_var('LLM_MODEL', 'gpt-5-mini')
            temperature = float(get_env_var('LLM_TEMPERATURE', '0.1'))  # Lower temperature for extraction
            max_tokens = int(get_env_var('LLM_MAX_TOKENS', '500'))
            
            # Generate response
            response = self.llm_client.chat.completions.create(
                model=model,
                messages=[
                    {
                        "role": "system", 
                        "content": f"You are a precise data extractor. Extract the {field_name} field of type {field_type} from the provided document content. Return only the extracted value, nothing else."
                    },
                    {"role": "user", "content": prompt}
                ],
                temperature=temperature,
                max_tokens=max_tokens
            )
            
            extracted_value = response.choices[0].message.content.strip()
            
            # Convert the extracted value to the appropriate type
            return self._convert_field_type(extracted_value, field_type)
            
        except Exception as e:
            print(f"Error extracting field {field_name} with LLM: {str(e)}")
            return None
    
    def _convert_field_type(self, value: str, field_type: str) -> Any:
        """Convert extracted string value to the appropriate field type"""
        try:
            if field_type == "string":
                return value
            elif field_type == "integer":
                return int(value)
            elif field_type == "float":
                return float(value)
            elif field_type == "boolean":
                return value.lower() in ["true", "1", "yes", "on"]
            elif field_type == "date":
                from datetime import datetime
                # Try to parse common date formats
                for fmt in ["%Y-%m-%d", "%m/%d/%Y", "%d/%m/%Y", "%Y-%m-%d %H:%M:%S"]:
                    try:
                        return datetime.strptime(value, fmt).isoformat()
                    except ValueError:
                        continue
                return value  # Return as string if parsing fails
            elif field_type == "list":
                # Try to parse as JSON list, otherwise return as single item list
                try:
                    import json
                    return json.loads(value)
                except:
                    return [value]
            else:
                return value
        except Exception as e:
            print(f"Error converting field type {field_type}: {str(e)}")
            return value  # Return original value if conversion fails
